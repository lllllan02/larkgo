package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	var (
		dir = flag.String("dir", "service", "è¦æ‰«æçš„æ ¹ç›®å½•ï¼ˆé»˜è®¤ä¸º serviceï¼‰")
	)
	flag.Parse()

	if err := scanAndGenerate(*dir); err != nil {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: %v\n", err)
		os.Exit(1)
	}
}

// scanAndGenerate é€’å½’æ‰«æç›®å½•ï¼Œæ‰¾åˆ°æ‰€æœ‰ types.go æ–‡ä»¶å¹¶ç”Ÿæˆå¯¹åº”çš„ types_gen.go
func scanAndGenerate(rootDir string) error {
	var count int
	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// è·³è¿‡ vendor å’Œéšè—ç›®å½•
		if info.IsDir() {
			name := info.Name()
			if name == "vendor" || name == ".git" || name == "node_modules" || strings.HasPrefix(name, ".") {
				return filepath.SkipDir
			}
			return nil
		}

		// åªå¤„ç† types.go æ–‡ä»¶
		if filepath.Base(path) != "types.go" {
			return nil
		}

		dir := filepath.Dir(path)
		outputFile := filepath.Join(dir, "types_gen.go")

		fmt.Printf("ğŸ” å‘ç° types.go: %s\n", path)

		if err := generateBuilder(path, outputFile); err != nil {
			fmt.Printf("   âš ï¸  è·³è¿‡ï¼ˆæ— éœ€ç”Ÿæˆï¼‰: %v\n", err)
			return nil
		}

		count++
		return nil
	})

	if err != nil {
		return err
	}

	fmt.Printf("\nâœ… å®Œæˆï¼å…±å¤„ç† %d ä¸ªæ–‡ä»¶\n", count)
	return nil
}

func generateBuilder(inputFile, outputFile string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("è§£ææ–‡ä»¶å¤±è´¥: %w", err)
	}

	var buf bytes.Buffer
	buf.WriteString("// Code generated by cmd/builder. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", node.Name.Name))

	hasContent := false

	// éå†æ‰€æœ‰ç±»å‹å®šä¹‰
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// åªå¤„ç†ä»¥ Req ç»“å°¾çš„ç»“æ„ä½“
		structName := typeSpec.Name.Name
		if !strings.HasSuffix(structName, "Req") {
			return true
		}

		// ç”Ÿæˆ New å‡½æ•°
		buf.WriteString(fmt.Sprintf("func New%s() *%s {\n", structName, structName))
		buf.WriteString(fmt.Sprintf("\treturn &%s{}\n", structName))
		buf.WriteString("}\n\n")

		// ä¸ºæ¯ä¸ªæŒ‡é’ˆå­—æ®µç”Ÿæˆ setter æ–¹æ³•
		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldName := field.Names[0].Name

			// åªå¤„ç†å¯¼å‡ºå­—æ®µï¼ˆå¤§å†™å¼€å¤´ï¼‰çš„æŒ‡é’ˆå­—æ®µ
			if !ast.IsExported(fieldName) {
				continue
			}

			starExpr, ok := field.Type.(*ast.StarExpr)
			if !ok {
				continue
			}

			// è·å–å­—æ®µç±»å‹ï¼ˆå»æ‰æŒ‡é’ˆï¼‰
			var typeName string
			switch t := starExpr.X.(type) {
			case *ast.Ident:
				typeName = t.Name
			case *ast.SelectorExpr:
				typeName = fmt.Sprintf("%s.%s", t.X, t.Sel.Name)
			default:
				continue
			}

			// æ–¹æ³•åï¼šWith + å­—æ®µå
			methodName := "With" + fieldName

			// å‚æ•°åï¼šå°†å­—æ®µåé¦–å­—æ¯å°å†™
			paramName := strings.ToLower(fieldName[:1]) + fieldName[1:]

			// ç”Ÿæˆ setter æ–¹æ³•
			buf.WriteString(fmt.Sprintf("func (req *%s) %s(%s %s) *%s {\n",
				structName, methodName, paramName, typeName, structName))
			buf.WriteString(fmt.Sprintf("\treq.%s = &%s\n", fieldName, paramName))
			buf.WriteString("\treturn req\n")
			buf.WriteString("}\n\n")

			hasContent = true
		}

		return true
	})

	if !hasContent {
		return fmt.Errorf("æ²¡æœ‰æ‰¾åˆ°éœ€è¦ç”Ÿæˆ builder æ–¹æ³•çš„ç»“æ„ä½“")
	}

	// æ ¼å¼åŒ–ä»£ç 
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// å¦‚æœæ ¼å¼åŒ–å¤±è´¥ï¼Œè¾“å‡ºåŸå§‹å†…å®¹ä»¥ä¾¿è°ƒè¯•
		fmt.Println("æ ¼å¼åŒ–å¤±è´¥ï¼Œè¾“å‡ºåŸå§‹å†…å®¹:")
		fmt.Println(buf.String())
		return fmt.Errorf("æ ¼å¼åŒ–ä»£ç å¤±è´¥: %w", err)
	}

	// å†™å…¥æ–‡ä»¶
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		return fmt.Errorf("å†™å…¥æ–‡ä»¶å¤±è´¥: %w", err)
	}

	fmt.Printf("   âœ… ç”Ÿæˆ: %s\n", outputFile)
	return nil
}
